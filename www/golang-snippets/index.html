
<!DOCTYPE html>
<html>

<head>
  
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8">

  <title>Golang snippets &mdash; Chuletas</title>

  <link rel="shortcut icon" href="../img/favicon.ico">
  <link rel="stylesheet" href="../css/alabaster.css" type="text/css">
  <link rel="stylesheet" href="../css/alabaster-overrides.css" type="text/css">

  
  <link href="../_extra/css/extra.css" rel="stylesheet">
  

  
  <script src="../_extra/js/highlight.pack.js"></script>
  
  <script src="../search/main.js"></script>
  

  <link rel="stylesheet" href="../_extra/css/atom-one-light.css">
  <script src="../_extra/js/highlight.pack.js"></script>

  <script>
    hljs.initHighlightingOnLoad();
  </script>

  

  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9">
  

</head>

<body>

  <div class="document">
    <div class="documentwrapper">
      <div class="bodywrapper">
        <div class="body" role="main">
          
          <h1 id="golang-snippets">GOLANG SNIPPETS</h1>
<hr />
<h2 id="sendreceive-data">SEND/RECEIVE DATA</h2>
<h3 id="sendresponse">SendResponse</h3>
<pre><code class="language-go">// SendResponse...
func SendResponse(w http.ResponseWriter, d interface{}, s int) {
    if d == nil {
        w.WriteHeader(s)
        return
    }
    dataJSON, err := json.MarshalIndent(d, &quot;&quot;, &quot; &quot;)
    if err != nil {
        log.Printf(&quot;ERROR Marshaling %v\n&quot;, err)
        http.Error(w, &quot;Internal Server Error&quot;, http.StatusInternalServerError)
        return
    }
    w.Header().Set(&quot;Content-Type&quot;, &quot;application/json&quot;)
    w.WriteHeader(s)
    _, err = w.Write(dataJSON)
    if err != nil {
        log.Printf(&quot;ERROR writing JSON response: %v\n&quot;, err)
    }
}

// SendtResponseXML ...
func SendResponseXML(w http.ResponseWriter, d interface{}, s int) {
    w.WriteHeader(s)
    if d == nil {
        return
    }
    w.Header().Set(&quot;Content-Type&quot;, &quot;application/xml&quot;)
    dataXML, err := xml.MarshalIndent(d, &quot;&quot;, &quot;  &quot;)
    if err != nil {
        log.Printf(&quot;ERROR Marshaling XML: %v\n&quot;, err)
        http.Error(w, &quot;Internal Server Error&quot;, http.StatusInternalServerError)
        return
    }
    _, err = w.Write(dataXML)
    if err != nil {
        log.Printf(&quot;ERROR writing XML response: %v\n&quot;, err)
    }
}
</code></pre>
<h3 id="fetch-get">Fetch GET</h3>
<pre><code class="language-go">// FetchGET ...
func FetchGET(url string, d interface{}) error {
    client := &amp;http.Client{
        Timeout: 10 * time.Second,
    }

    // PARAMS IN URL
    u, err := url.Parse(BASE_URL)
    if err != nil {
        err := fmt.Sprintf(&quot;ERROR Parsing URL =&gt; %v&quot;, err)
    }
    params := url.Values{
        &quot;key&quot;: {API_KEY},
        &quot;aqi&quot;: {&quot;no&quot;},
        &quot;q&quot;:   {city},
    }
    u.RawQuery = params.Encode()
    path := u.String()

    // HEADERS
    req, err := http.NewRequest(&quot;GET&quot;, path, nil)
    if err != nil {
        log.Printf(&quot;ERROR: creating request %s =&gt; %v&quot;, path, err)
        return err
    }
    req.Header.Set(&quot;Authorization&quot;, &quot;Bearer ACCESS_TOKEN&quot;)
    req.Header.Set(&quot;Accept&quot;, &quot;application/json&quot;)
    resp, err := client.Do(req) 
    if err != nil {
        log.Printf(&quot;ERROR: Request %s =&gt; %v&quot;, path, err)
        return err
    }
    /////

    // NO HEADERS
    resp, err := client.Get(path)
    if err != nil {
        log.Printf(&quot;ERROR: Request %s =&gt; %v&quot;, path, err)
        return err
    }
    /////

    // common
    defer resp.Body.Close()

    if resp.StatusCode &lt; 200 || resp.StatusCode &gt;= 300 {
        err := errors.New(&quot;HTTP status:&quot; + http.StatusText(resp.StatusCode))
        log.Printf(&quot;ERROR: %v&quot;, err)
        return err
    }

    decoder := json.NewDecoder(resp.Body)
    err = decoder.Decode(&amp;d)
    if err != nil {
        log.Printf(&quot;ERROR unnmarshalling =&gt; %v&quot;, err)
        return err
    }

    return nil
}
</code></pre>
<h3 id="dogetconcurrentrequest">DoGetConcurrentRequest</h3>
<pre><code class="language-go">func fillDefaultStocks(links []string) {
    ch := make(chan []byte)
    for _, link := range links {
        go doGetConcurrentRequest(link, ch)
    }
    for range links {
        json.Unmarshal(&lt;-ch, &amp;stocks)
    }
}

func doGetConcurrentRequest(url string, ch chan&lt;- []byte) {
    resp, err := http.Get(url)
    if err != nil {
        msg := fmt.Sprintf(&quot;ERROR 1 HTTP Request %s&quot;, err)
        log.Printf(msg)
        ch &lt;- []byte(msg)
        return
    }
    if resp.StatusCode != 200 {
        msg := fmt.Sprintf(&quot;ERROR 2 Status Code %d&quot;, resp.StatusCode)
        log.Printf(msg)
        ch &lt;- []byte(msg)
        return
    }
    defer resp.Body.Close()
    body, err := ioutil.ReadAll(resp.Body)
    if err != nil {
        msg := fmt.Sprintf(&quot;ERROR 3 HTTP Request %s&quot;, err)
        log.Printf(msg)
        ch &lt;- []byte(msg)
        return
    }
    ch &lt;- body
}
</code></pre>
<h3 id="fetchpost">fetchPOST</h3>
<pre><code class="language-go">// FetchPOST ...
func FetchPOST(url string, d interface{}) error {
    client := &amp;http.Client{
        Timeout: 10 * time.Second,
    }

    jsonData, err := json.Marshal(d)
    if err != nil {
        log.Printf(&quot;ERROR: Failed to marshal request body =&gt; %v&quot;, err)
        return err
    }

    req, err := http.NewRequest(&quot;POST&quot;, url, bytes.NewBuffer(jsonData))
    if err != nil {
        log.Printf(&quot;ERROR: Failed to create request for %s =&gt; %v&quot;, url, err)
        return err
    }

    req.Header.Set(&quot;Authorization&quot;, &quot;Bearer ACCESS_TOKEN&quot;)
    req.Header.Set(&quot;Accept&quot;, &quot;application/json&quot;)
    req.Header.Set(&quot;Content-Type&quot;, &quot;application/json&quot;)

    resp, err := client.Do(req)
    if err != nil {
        log.Printf(&quot;ERROR: Request %s =&gt; %v&quot;, url, err)
        return err
    }
    defer resp.Body.Close()

    if resp.StatusCode &lt; 200 || resp.StatusCode &gt;= 300 {
        err := errors.New(&quot;HTTP status: &quot; + http.StatusText(resp.StatusCode))
        log.Printf(&quot;ERROR: %v&quot;, err)
        return err
    }

    decoder := json.NewDecoder(resp.Body)
    err = decoder.Decode(&amp;d)
    if err != nil {
        log.Printf(&quot;ERROR unmarshalling =&gt; %v&quot;, err)
        return err
    }

    return nil
}

</code></pre>
<h3 id="fetchpost-with-params">fetchPOST with params</h3>
<pre><code class="language-go">import (
    url &quot;net/url&quot;
)

// FetchPOSTparams ...
func FetchPOSTparams(path string, d map[string]string) error {
    client := &amp;http.Client{
        Timeout: 10 * time.Second,
    }

    params := url.Values{}
    for key, value := range d {
        params.Add(key, value)
    }
    /*params := url.Values{
        &quot;test&quot;: {myTest},
        &quot;data&quot;: {myData},
    }*/

    body := bytes.NewBufferString(params.Encode())

    req, err := http.NewRequest(&quot;POST&quot;, path, body)
    if err != nil {
        log.Printf(&quot;ERROR: Failed to create request for %s =&gt; %v&quot;, path, err)
        return err
    }

    req.Header.Set(&quot;Authorization&quot;, &quot;Bearer YOUR_ACCESS_TOKEN&quot;)
    req.Header.Set(&quot;Accept-Charset&quot;, &quot;utf-8&quot;)
    req.Header.Set(&quot;Content-Type&quot;, &quot;application/x-www-form-pathencoded&quot;)

    resp, err := client.Do(req)
    if err != nil {
        log.Printf(&quot;ERROR: Request %s =&gt; %v&quot;, path, err)
        return err
    }
    defer resp.Body.Close()

    if resp.StatusCode &lt; 200 || resp.StatusCode &gt;= 300 {
        err := errors.New(&quot;HTTP status: &quot; + http.StatusText(resp.StatusCode))
        log.Printf(&quot;ERROR: %v&quot;, err)
        return err
    }

    return nil
}
</code></pre>
<h3 id="getinterfacestypes">GetInterfacesTypes</h3>
<pre><code class="language-go">// GetInterfacesTypes ...
func GetInterfacesTypes(f interface{}) {
    switch vf := f.(type) {
    case map[string]interface{}:
        //fmt.Println(&quot;is a map:&quot;)
        for k, v := range vf {
            switch vv := v.(type) {
            case string:
                //fmt.Printf(&quot;%v: is string - %q\n&quot;, k, vv)
            case int:
                //fmt.Printf(&quot;%v: is int - %q\n&quot;, k, vv)
            case float64:
                //fmt.Printf(&quot;%v: is float64 - %g\n&quot;, k, vv)
            default:
                fmt.Sprintln(k, v, vv)
                //fmt.Printf(&quot;%v: &quot;, k)
                GetInterfacesTypes(v)
            }
        }
    case []interface{}:
        //fmt.Println(&quot;is an array:&quot;)
        for k, v := range vf {
            switch vv := v.(type) {
            case string:
                //fmt.Printf(&quot;%v: is string - %q\n&quot;, k, vv)
            case int:
                //fmt.Printf(&quot;%v: is int - %q\n&quot;, k, vv)
            case float64:
                //fmt.Printf(&quot;%v: is float64 - %g\n&quot;, k, vv)
                if k == 4 {
                    fmt.Println(`ALELUYA==&gt;`, vv)
                }
            default:
                fmt.Sprintln(k, v, vv)
                //fmt.Printf(&quot;%v: &quot;, k)
                GetInterfacesTypes(v)
            }
        }
    }
}
</code></pre>
<h3 id="isjson">IsJSON</h3>
<pre><code class="language-go">// IsJSON ...
func IsJSON(str string) bool {
    var js json.RawMessage
    return json.Unmarshal([]byte(str), &amp;js) == nil
}
</code></pre>
<h3 id="ispointer">IsPointer</h3>
<pre><code class="language-go">func IsPointer(d interface{}) bool {
    return reflect.TypeOf(d).Kind() == reflect.Ptr
}
</code></pre>
<hr />
<h2 id="files">FILES</h2>
<h3 id="readfile">ReadFile</h3>
<pre><code class="language-go">// ReadFile ...
func ReadFile(filePath string) (string, error) {
    data, err := ioutil.ReadFile(filePath)
    if err != nil {
        return &quot;&quot;, err
    }
    return string(data), nil
}

// ReadFileLineByLine ...
func ReadFileLineByLine(filePath string) ([]string, error) {
    file, err := os.Open(filePath)
    if err != nil {
        return nil, err
    }
    defer file.Close()

    var lines []string
    scanner := bufio.NewScanner(file)
    for scanner.Scan() {
        lines = append(lines, scanner.Text())
    }

    if err := scanner.Err(); err != nil {
        return nil, err
    }

    return lines, nil
}

</code></pre>
<h3 id="writefile">WriteFile</h3>
<pre><code class="language-go">// WriteFile ...
func WriteFile(filePath string, content string) error {
    file, err := os.Create(filePath)
    if err != nil {
        return err
    }
    defer file.Close()

    _, err = file.WriteString(content)
    if err != nil {
        return err
    }

    return nil
}
</code></pre>
<h3 id="loadjson-from-file">LoadJSON from File</h3>
<pre><code class="language-go">// LoadJSONFIleDecoder ... use streams
func LoadJSONFileDecoder(filePath string, data interface{}) error {
    file, err := os.Open(filePath)
    if err != nil {
        return err
    }
    defer file.Close()

    decoder := json.NewDecoder(file)
    err = decoder.Decode(data)
    if err != nil {
        return err
    }

    return nil
}

// LoadJSONFileMarschall ... loads all
func LoadJSONFileMarshall(filePath string, data interface{}) error {
    file, err := os.Open(filePath)
    if err != nil {
        return err
    }
    defer file.Close()

    body, err := ioutil.ReadAll(file)
    if err != nil {
        return err
    }

    err = json.Unmarshal(body, data)
    if err != nil {
        return err
    }

    return nil
}

</code></pre>
<h3 id="writejsontofile">WriteJSONtoFile</h3>
<pre><code class="language-go">// WriteJSONtoFile ...
func WriteJSONtoFile(filePath string, d interface{}) error {
    f, err := os.Create(filePath)
    if err != nil {
        return err
    }
    defer f.Close()

    encoder := json.NewEncoder(f)
    err = encoder.Encode(d)
    if err != nil {
        return err
    }

    return nil
}
</code></pre>
<h3 id="downloadfile">DownloadFile</h3>
<pre><code class="language-go">// DownloadFile ...
func DownloadFile(filePath string, url string) error {
    out, err := os.Create(filePath)
    if err != nil {
        return err
    }
    defer out.Close()

    resp, err := http.Get(url)
    if err != nil {
        return err
    }
    defer resp.Body.Close()

    if resp.StatusCode != http.StatusOK {
        return fmt.Errorf(&quot;ERROR Downloading file: %d&quot;, resp.StatusCode)
    }

    _, err = io.Copy(out, resp.Body)
    if err != nil {
        return err
    }

    return nil
}

</code></pre>
<h3 id="sendfilefromservertoclient">SendFileFromServerToClient</h3>
<pre><code class="language-go">func Index(w http.ResponseWriter, r *http.Request) {
    url := &quot;http://upload.wikimedia.org/wikipedia/en/b/bc/Wiki.png&quot;

    timeout := time.Duration(5) * time.Second
    transport := &amp;http.Transport{
        ResponseHeaderTimeout: timeout,
        Dial: func(network, addr string) (net.Conn, error) {
            return net.DialTimeout(network, addr, timeout)
        },
        DisableKeepAlives: true,
    }
    client := &amp;http.Client{
        Transport: transport,
    }
    resp, err := client.Get(url)
    if err != nil {
        fmt.Println(err)
    }
    defer resp.Body.Close()

    //copy the relevant headers. If you want to preserve the downloaded 
    // file name, extract it with go's url parser.
    w.Header().Set(&quot;Content-Disposition&quot;, &quot;attachment; filename=Wiki.png&quot;)
    w.Header().Set(&quot;Content-Type&quot;, r.Header.Get(&quot;Content-Type&quot;))
    w.Header().Set(&quot;Content-Length&quot;, r.Header.Get(&quot;Content-Length&quot;))

    //stream the body to the client without fully loading it into memory
    io.Copy(w, resp.Body)
}

func main() {
    http.HandleFunc(&quot;/&quot;, Index)
    err := http.ListenAndServe(&quot;:8000&quot;, nil)

    if err != nil {
        fmt.Println(err)
    }
}
</code></pre>
<h3 id="parsecsvfile">ParseCSVFile</h3>
<pre><code class="language-csv">// file.csv
&quot;AAPL&quot;,&quot;Apple Inc&quot;,&quot;4.10%&quot;
&quot;AMZN&quot;,&quot;Amazon.com Inc&quot;,&quot;3.49%&quot;
&quot;MSFT&quot;,&quot;Microsoft Corp&quot;,&quot;3.23%&quot;
&quot;GOOGL&quot;,&quot;Alphabet Inc&quot;,&quot;3.09%&quot;
</code></pre>
<pre><code class="language-go">type stock struct {
    Symbol string `json:&quot;symbol&quot;`
}

func main() {
    csvFile, _ := os.Open(&quot;sp.csv&quot;)
    reader := csv.NewReader(bufio.NewReader(csvFile))
    var stocks []stock
    for {
        line, error := reader.Read()
        if error == io.EOF {
            break
        }
        aux := stock{
            Symbol: line[0],
        }
        stocks = append(stocks, aux)
    }
    //stocksJSON, _ := json.Marshal(stocks)
    //fmt.Println(string(stocksJSON))

    f, err := os.Create(&quot;spList.json&quot;)
    if err != nil {
        panic(err)
    }
    defer f.Close()
    e := json.NewEncoder(f)
    e.Encode(&amp;stocks)
    fmt.Println(`END`)
}
</code></pre>
<pre><code class="language-json">// result
[
  {
    &quot;symbol&quot;: &quot;AAPL&quot;
  },
  {
    &quot;symbol&quot;: &quot;AMZN&quot;
  },
  {
    &quot;symbol&quot;: &quot;MSFT&quot;
  },
  {
    &quot;symbol&quot;: &quot;GOOGL&quot;
    }
]
</code></pre>
<hr />
<h2 id="http-server">HTTP SERVER</h2>
<p>Lectura </p>
<p><a href="https://www.alexedwards.net/blog/a-recap-of-request-handling">Request Handling in Go</a></p>
<pre><code class="language-go">type Handler interface {
    ServeHttp( ResponseWriter, *Request )
}
</code></pre>
<h3 id="wrapper">Wrapper</h3>
<p>Es muy sencillo pero luego complica para testearlo</p>
<pre><code class="language-go">mux.HandleFunc(&quot;/path&quot;, func(w http.ResponseWriter, r *http.Request) {
        nombreFuncion(w, r, loQueQueramosPasar)
})
</code></pre>
<h3 id="handle-handlefunc">Handle + HandleFunc</h3>
<pre><code class="language-go">package main

import (
    &quot;fmt&quot;
    &quot;net/http&quot;
    &quot;time&quot;
)

func timeHandler1(w http.ResponseWriter, r *http.Request) {
    tm := time.Now().Format(time.RFC1123)
    fmt.Println(&quot;/time/&quot; + tm)
    w.Write([]byte(&quot;The time is: &quot; + tm))
}

func timeHandler2(format string) http.Handler {
    return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request){
        tm := time.Now().Format(format)
        fmt.Println(&quot;/time/&quot; + tm)
        w.Write([]byte(&quot;The time is: &quot; + tm))
    })
}

/*  lo mismo pero con conversion implicita al tipo HandlerFunc
func timeHandler2(format string) http.HandlerFunc {
    return func(w http.ResponseWriter, r *http.Request) {
        tm := time.Now().Format(format)
        fmt.Println(&quot;/time/&quot; + tm)
        w.Write([]byte(&quot;The time is: &quot; + tm))
    }
}
*/

func hiHandler(w http.ResponseWriter, r *http.Request) {
    fmt.Println(&quot;/hello&quot;)
    w.Write([]byte(&quot;/hello&quot;))
}

func main() {
    mux := http.NewServeMux()

    // Creamos un closure con las variables que queremos usar
    th2 := timeHandler2(time.RFC3339)

    mux.HandleFunc(&quot;/time/1&quot;, timeHandler1)
    mux.Handle(&quot;/time/2&quot;, th2)
    mux.HandleFunc(&quot;/hello&quot;, hiHandler)

    //http.HandleFunc(&quot;/time/1&quot;, timeHandler1)
    //http.Handle(&quot;/time/2&quot;, th2)
    //http.HandleFunc(&quot;/hello&quot;, hiHandler)

    http.ListenAndServe(&quot;:3000&quot;, mux /*nil*/)
}

</code></pre>
<h3 id="handler">Handler</h3>
<pre><code class="language-go">type specificHandler struct {
    Thing string
}

func(h *specificHandler)ServeHTTP(w http.ResponseWriter,r *http.Request) {
    w.Write(h.Thing)
}

func main() {
  http.Handle(&quot;/something&quot;, &amp;specificHandler{Thing: &quot;Hello world!&quot;})
  http.ListenAndServe(&quot;:8080&quot;, nil)
}
</code></pre>
<pre><code class="language-go">package main

import (
    &quot;fmt&quot;
    &quot;net/http&quot;
    &quot;time&quot;
)

type timeHandler struct {
    format string
}

func (th *timeHandler) ServeHTTP(w http.ResponseWriter, r *http.Request) {
    tm := time.Now().Format(th.format)
    fmt.Println(&quot;/time/&quot; + tm)
    w.Write([]byte(&quot;The time is: &quot; + tm))
}

type hiHandler struct{}

func (ti *hiHandler) ServeHTTP(w http.ResponseWriter, r *http.Request) {
    fmt.Println(&quot;/hello&quot;)
    w.Write([]byte(&quot;/hello&quot;))
}

func main() {
    /mux := http.NewServeMux()

    th1 := &amp;timeHandler{format: time.RFC1123}
    th2 := &amp;timeHandler{format: time.RFC3339}
    hi := &amp;hiHandler{}

    mux.Handle(&quot;/time/1&quot;, th1)
    mux.Handle(&quot;/time/2&quot;, th2)
    mux.Handle(&quot;/hello&quot;, hi)

    //http.Handle(&quot;/time/1&quot;, th1)
    //http.Handle(&quot;/time/2&quot;, th2)
    //http.Handle(&quot;/hello&quot;, hi)

    http.ListenAndServe(&quot;:3000&quot;, /*nil*/ mux)
}
</code></pre>
<h3 id="ejemplo-completo">Ejemplo Completo</h3>
<pre><code class="language-go">package main

import (
    &quot;errors&quot;
    &quot;fmt&quot;
    &quot;log&quot;
    &quot;net/http&quot;
    &quot;os&quot;
    &quot;time&quot;

    _ &quot;github.com/go-sql-driver/mysql&quot;
)

type app struct {
    Config struct {
        Mode          string `json:&quot;mode&quot;`
        Port          int    `json:&quot;port&quot;`
        Valid         string `json:&quot;valid&quot;`
        ErrorsLogFile string `json:&quot;errorsLogFile&quot;`
        HitsLogFile   string `json:&quot;hitsLogFile&quot;`
    } `json:&quot;config&quot;`
    Mysql struct {
        User      string `json:&quot;user&quot;`
        Password  string `json:&quot;password&quot;`
        DB        string `json:&quot;db&quot;`
        Host      string `json:&quot;host&quot;`
        Port      int    `json:&quot;port&quot;`
        TableBW   string `json:&quot;tableBw&quot;`
        TableHits string `json:&quot;tableHits&quot;`
    }
}

type requestError struct {
    Error      error  `json:&quot;-&quot;`
    Message    string `json:&quot;message&quot;`
    StatusCode int    `json:&quot;-&quot;`
}

func (a *app) ServeHTTP(w http.ResponseWriter, r *http.Request) {
    r.ParseForm()
    valid := r.Form.Get(&quot;test&quot;)
    if valid != a.Config.Valid {
        http.Error(w, &quot;Unauthorized&quot;, http.StatusUnauthorized)
        return
    }
    updateBw(w, r, a)
}

func main() {
    var a app
    loadConfigJSON(&amp;a)
    checkMode(&amp;a)

    // Custom Log File
    if a.Config.Mode == &quot;production&quot; {
        var f = a.Config.ErrorsLogFile
        mylog, err := os.OpenFile(f, os.O_WRONLY|os.O_CREATE|os.O_APPEND
                , 0644)
        if err != nil {
            log.Printf(&quot;ERROR opening log file %s\n&quot;, err)
        }
        defer mylog.Close() // defer must be in main
        log.SetOutput(mylog)
    }

    mux := http.NewServeMux()

    mux.Handle(&quot;/savebw/&quot;, &amp;a)
    mux.Handle(&quot;/saveHits/&quot;, checkValid(
        func(w http.ResponseWriter, r *http.Request) {
            updateHits(w, r, &amp;a)
        }, a.Config.Valid))
    mux.HandleFunc(&quot;/get/&quot;, checkValid(
        func(w http.ResponseWriter, r *http.Request) {
            getStats(w, r, &amp;a)
        }, a.Config.Valid))
    mux.HandleFunc(&quot;/&quot;, badRequest)

    server := http.Server{
        Addr:           fmt.Sprintf(&quot;localhost:%d&quot;, a.Config.Port),
        Handler:        mux,
        ReadTimeout:    10 * time.Second,
        WriteTimeout:   30 * time.Second,
        MaxHeaderBytes: 1 &lt;&lt; 20,
    }

    log.Printf(&quot;Server up listening %s in mode %s&quot;, server.Addr
            , a.Config.Mode)
    server.ListenAndServe()

}

func checkValid(next http.HandlerFunc, test string) http.HandlerFunc {
    return func(w http.ResponseWriter, r *http.Request) {
        r.ParseForm()
        valid := r.Form.Get(&quot;test&quot;)
        if valid != test {
            http.Error(w, &quot;Unauthorized&quot;, http.StatusUnauthorized)
            return
        }
        next.ServeHTTP(w, r)
    }
}

func badRequest(w http.ResponseWriter, r *http.Request) {
    re := &amp;requestError{
        Error:      errors.New(&quot;Unexistent Endpoint&quot;),
        Message:    &quot;Bad Request&quot;,
        StatusCode: 400,
    }
    sendErrorToClient(w, re)
}
</code></pre>
<hr />
<h2 id="network">NETWORK</h2>
<h3 id="getip">GetIP</h3>
<pre><code class="language-go">// GetIP ...
func GetIP(r *http.Request) string {
    headers := []string{
        &quot;X-Forwarded-For&quot;,
        &quot;X-Real-IP&quot;,
        &quot;CF-Connecting-IP&quot;,
    }
    for _, header := range headers {
        ips := r.Header.Get(header)
        if ips != &quot;&quot; {
            return strings.TrimSpace(strings.Split(ips, &quot;,&quot;)[0])
        }
    }
    ip := r.RemoteAddr
    colon := strings.LastIndex(ip, &quot;:&quot;)
    if colon != -1 {
        ip = ip[:colon]
    }
    return strings.TrimSpace(ip)
}
</code></pre>
<h3 id="getrequestorigin">GetRequestOrigin</h3>
<pre><code class="language-go">func GetRequestOrigin(r *http.Request) string {
    switch {
    case r.Header.Get(&quot;Host&quot;) != &quot;&quot;:
        return r.Header.Get(&quot;Host&quot;)
    case r.Header.Get(&quot;Origin&quot;) != &quot;&quot;:
        return r.Header.Get(&quot;Origin&quot;)
    case r.Header.Get(&quot;Referer&quot;) != &quot;&quot;:
        return r.Header.Get(&quot;Referer&quot;)
    default:
        return &quot;?????&quot;
    }
}
</code></pre>
<h3 id="isvalidurl">IsValidURL</h3>
<pre><code class="language-go">// IsValidURL ...
func IsValidURL(rawurl string) bool {
    rawurl = strings.TrimSpace(rawurl) 
    parsedURL, err := url.Parse(rawurl)
    if err != nil {
        return false
    }   
    if parsedURL.Scheme != &quot;http&quot; &amp;&amp; parsedURL.Scheme != &quot;https&quot; {
        return false
    }
    if parsedURL.Host == &quot;&quot; {
        return false
    }
    return true
}
</code></pre>
<h3 id="existsurl">ExistsURL</h3>
<pre><code class="language-go">// ExistsURL ...
func ExistsURL(myUrl string) bool {
    client := http.Client{
        Timeout: 5 * time.Second,
        CheckRedirect: func(req *http.Request, via []*http.Request) error {
            return http.ErrUseLastResponse // Dont follow redirections
        },
    }

    resp, err := client.Head(myUrl)
    if err != nil {
        return false
    }
    defer resp.Body.Close()

    return resp.StatusCode &gt;= 200 &amp;&amp; resp.StatusCode &lt; 400
}
</code></pre>
<h3 id="getlanguage">GetLanguage</h3>
<pre><code class="language-go">// GetLanguage ...
func GetLanguage(r *http.Request) string {
    lang := r.Header.Get(&quot;Accept-Language&quot;)
    if lang != &quot;&quot; {
        langs := strings.SplitN(lang, &quot;,&quot;, 2)
        return strings.ToLower(strings.TrimSpace(langs[0]))
    }
    return &quot;en&quot;
}

</code></pre>
<h3 id="removeprotocolfromurl">RemoveProtocolFromURL</h3>
<pre><code class="language-go">// RemoveProtocol ...
func RemoveProtocol(url string) string {
    if strings.HasPrefix(url, &quot;https://&quot;) {
        return url[8:]
    }
    if strings.HasPrefix(url, &quot;http://&quot;) {
        return url[7:]
    }
    return url
}
</code></pre>
<h3 id="removeprotocolandwwwfromurl">RemoveProtocolAndWWWFromURL</h3>
<pre><code class="language-go">// RemoveProtocolAndWWW ...
func RemoveProtocolAndWWWL(url string) string {
    url = RemoveProtocol(url)
    if strings.HasPrefix(url, &quot;www.&quot;) {
        return url[4:]
    }
    return url
}
</code></pre>
<h3 id="nginx-return-444">Nginx return 444</h3>
<pre><code class="language-go">func close(w http.ResponseWriter, r *http.Request) {
    hijacker, ok := w.(http.Hijacker)
    if !ok {
        http.Error(w, &quot;Server does not support hijacking&quot;, http.StatusInternalServerError)
        return
    }
    conn, _, err := hijacker.Hijack()
    if err != nil {
        http.Error(w, err.Error(), http.StatusInternalServerError)
        return
    }
    conn.Close()
    return
}
</code></pre>
<h3 id="slow-response">Slow Response</h3>
<pre><code class="language-go">func slowSend(w http.ResponseWriter, r *http.Request) {
    flusher, ok := w.(http.Flusher)
    if !ok {
        err := &quot;Server does not support flusher&quot;
        http.Error(w, err, http.StatusInternalServerError)
        return
    }

    w.Header().Set(&quot;Content-Type&quot;, &quot;text/plain&quot;)
    fmt.Fprintln(w, &quot;Initiating slow response...&quot;)

    for i := 0; i &lt; 100; i++ {
        fmt.Fprintf(w, &quot;Fragmento %d\n&quot;, i+1)
        flusher.Flush()
        time.Sleep(1 * time.Second)
    }

    fmt.Fprintln(w, &quot;Task accomplished&quot;)
}

func holdConn(w http.ResponseWriter, r *http.Request) {
    fmt.Fprintf(w, &quot;Begin.............&quot;)
    time.Sleep(60 * time.Second)
    fmt.Fprintf(w, &quot;Thats all&quot;)
}
</code></pre>
<hr />
<h2 id="numbers">NUMBERS</h2>
<h3 id="getrandomint">GetRandomInt</h3>
<pre><code class="language-go">import (
    &quot;time&quot;

    &quot;golang.org/x/exp/rand&quot;
)

// RandomInt ... min and max included
func RandomInt(min, max int) int {
    r := rand.New(rand.NewSource(time.Now().UnixNano()))
    return r.Intn(max-min+1) + min
}
</code></pre>
<h3 id="roundfloat64">RoundFloat64</h3>
<pre><code class="language-go">// RoundFloat64 ... rounds float64 into integer
func RoundFloat64(num float64) int {
    if num &lt; 0 {
        return int(num - 0.5)
    }
    return int(num + 0.5)
}
</code></pre>
<h3 id="roundfloat32">RoundFloat32</h3>
<pre><code class="language-go">// RoundFloat32 ... rounds float32 into integer
func RoundFloat32(num float32) int {
    if num &lt; 0 {
        return int(num - 0.5)
    }
    return int(num + 0.5)
}
</code></pre>
<h3 id="reversesliceint">ReverseSliceInt</h3>
<pre><code class="language-go">// ReverseSliceInt ... [0,1,2,3,4,5] ==&gt; [5,4,3,2,1,0]
func ReverseSliceInt(reverse []int) []int {
    for i, j := 0, len(reverse)-1; i &lt; j; i, j = i+1, j-1 {
        reverse[i], reverse[j] = reverse[j], reverse[i]
    }
    return reverse
}
</code></pre>
<h3 id="transposematrixint">TransposeMatrixInt</h3>
<pre><code class="language-go">// TransposeMatrixInt ... rows &gt; cols or cols &gt; rows
// but rows.elements &gt;= cols.elements
func TransposeMatrixInt(matrix [][]int) [][]int {
    if len(matrix) == 0 {
        return [][]int{}
    }

    result := make([][]int, len(matrix[0]))
    for i := range result {
        result[i] = make([]int, len(matrix))
    }

    for y, row := range matrix {
        for x, value := range row {
            result[x][y] = value
        }
    }
    return result
}

</code></pre>
<h3 id="slicecontainsint">SliceContainsInt</h3>
<pre><code class="language-go">// SliceContainsInt ... returns true/false
func SliceContainsInt(num int, slice []int) bool {
    for _, v := range slice {
        if v == num {
            return true
        }
    }
    return false
}
</code></pre>
<hr />
<h2 id="strings">STRINGS</h2>
<h3 id="removeallwhitespaces">RemoveAllWhitespaces</h3>
<pre><code class="language-go">import &quot;strings&quot;

// RemoveAllWhitespaces ...
func RemoveAllWhitespaces(str string) string {
    return strings.ReplaceAll(str, &quot; &quot;, &quot;&quot;)
}
</code></pre>
<h3 id="replaceallwhitespacesbychar">ReplaceAllWhitespacesByChar</h3>
<pre><code class="language-go">import &quot;strings&quot;

// ReplaceAllWhitespacesByChar ...
func ReplaceAllWhitespacesByChar(str, otherChar string) string {
    return strings.ReplaceAll(str, &quot; &quot;, otherChar)
}
</code></pre>
<h3 id="reverseslicestring">ReverseSliceString</h3>
<pre><code class="language-go">// ReverseSliceString [&quot;H&quot;,&quot;O&quot;,&quot;L&quot;,&quot;A&quot;] ==&gt; [&quot;A&quot;,&quot;L&quot;,&quot;O&quot;,&quot;H&quot;]
func ReverseSliceString(reverse []string) []string {
    for i, j := 0, len(reverse)-1; i &lt; j; i, j = i+1, j-1 {
        reverse[i], reverse[j] = reverse[j], reverse[i]
    }
    return reverse
}
</code></pre>
<h3 id="transposematrixstring">TransposeMatrixString</h3>
<pre><code class="language-go">// TransposeMatrixString rows &gt; cols or cols &gt; rows
// but rows.elements &gt;= cols.elements
func TransposeMatrixString(matrix [][]string) [][]string {
    if len(matrix) == 0 || len(matrix[0]) == 0 {
        return [][]string{}
    }

    result := make([][]string, len(matrix[0]))
    for i := range result {
        result[i] = make([]string, len(matrix))
    }
    for y, row := range matrix {
        for x, value := range row {
            result[x][y] = value
        }
    }
    return result
}

</code></pre>
<h3 id="slicecontainsstring">SliceContainsString</h3>
<pre><code class="language-go">// SliceContainsString ... returns true/false
func SliceContainsString(str string, slice []string) bool {
    for _, v := range slice {
        if v == str {
            return true
        }
    }
    return false
}
</code></pre>
<hr />
<h2 id="os">OS</h2>
<h3 id="execcommand">execCommand</h3>
<pre><code class="language-go">import (
    &quot;fmt&quot;
    &quot;os/exec&quot;
)

func main()  {
    command := []string{&quot;vnstat&quot;, &quot;-i&quot;, ifinterface, &quot;--json&quot;}
    ///fmt.Println(&quot;Command =&gt;&quot;, command)
    chunk, err := execCommand(command)
    if err != nil {
        log.Fatal(err)
    }
    //fmt.Println(`CHUNK =&gt;`, string(chunk))
}

func execCommand(args []string) (err error) {
    _, err = exec.Command(args[0], args[1:]...).CombinedOutput()
    if err != nil {
        fmt.Println(err)
        return err
    }
    return err
}

func execCommand(args []string) (c []byte, err error) {
    c, err = exec.Command(args[0], args[1:]...).CombinedOutput()
    if err != nil {
        return nil, err
    }
    return c, err
}

func execCommand(comm string) {
    _, err := exec.Command(&quot;sh&quot;, &quot;-c&quot;, comm).CombinedOutput()
    if err != nil {
        log.Fatal(err)
    }
}
</code></pre>
<hr />
<h2 id="time">TIME</h2>
<h3 id="parsestringtotime">ParseStringToTime</h3>
<pre><code class="language-go">import &quot;time&quot;

// ParseStringToTime ...
func ParseStringToTime(start string) (time.Time, error) {
    formats := []string{
        time.RFC3339,
        &quot;2006-01-02T15:04:05&quot;,
        &quot;2006-01-02&quot;,
    }

    for _, layout := range formats {
        t, err := time.Parse(layout, start)
        if err == nil {
            return t, nil
        }
    }

    fail := fmt.Errorf(&quot;Fail parsing time: %s&quot;, start)
    return time.Time{}, fail
}
</code></pre>
<h3 id="onceadaytask">OnceADayTask</h3>
<pre><code class="language-go">func main() {
    go onceADayTask(3, 10, 10)
    select {}
}

func onceADayTask(h, m, s int) {
    t := time.Now()
    n := time.Date(
        t.Year(), t.Month(), t.Day(),
        h, m, s, 0,
        t.Location(),
    )
    if n.Before(t) {
        n = n.Add(24 * time.Hour)
    }

    for {
        time.Sleep(time.Until(n))
        doSomeTask()
        n = n.Add(24 * time.Hour)
    }
}

func doSomeTask() {
    fmt.Printf(&quot;Hi: %s\n&quot;, time.Now().Format(&quot;03:04:05 PM&quot;))
}
</code></pre>
<h3 id="setinterval">SetInterval</h3>
<pre><code class="language-go">func main() {
    ticker := time.NewTicker(1 * time.Second)
    defer ticker.Stop()
    done := make(chan bool)
    go func() {
        for {
            select {
            case &lt;-ticker.C:
                fmt.Println(&quot;Ticker every X * time.Second&quot;)
            case &lt;-done:
                return
            }
        }
    }()
    time.Sleep(5 * time.Second)
    done &lt;- true
    fmt.Println(&quot;Ticker stopped. Exiting program.&quot;)
}
</code></pre>
<pre><code class="language-go">func main() {
    go interval()
    select {}
}
func interval() {
    ticker := time.NewTicker(2 * time.Second)
    defer ticker.Stop()

    for range ticker.C {
        fmt.Println(&quot;Hi Every 2 secs&quot;)
    }
}
</code></pre>
<hr />
<h2 id="logs">LOGS</h2>
<h3 id="custom-logs">Custom Logs</h3>
<pre><code class="language-go">// main.go
/////// Custom Error Log File + Custom Info Log File /////////
iLog := createCustomInfoLogFile2(a.Conf.InfoLogFile)
mylog := createCustomErrorLogFile(a.Conf.ErrorsLogFile)
defer mylog.Close()
//////////////////////////////////////////////////////////////

// ya por donde queramos
func createCustomErrorLogFile(f string) *os.File {
    mylog,err:=os.OpenFile(f,os.O_WRONLY|os.O_CREATE|os.O_APPEND,0644)
    if err != nil {
        log.Fatalf(&quot;ERROR opening Error log file %s\n&quot;, err)
    }
    log.SetOutput(mylog)
    return mylog
}

func createCustomInfoLogFile2(f string) *log.Logger {
    infoLog,err:=os.OpenFile(f,os.O_WRONLY|os.O_CREATE|os.O_APPEND,0644)
    if err != nil {
        log.Fatalf(&quot;ERROR opening Info log file %s\n&quot;, err)
    }
    var iLog *log.Logger
    iLog = log.New(infoLog, &quot;INFO :\t&quot;, log.Ldate|log.Ltime)
    return iLog
}
</code></pre>
<pre><code class="language-go">const (
    errorLogFile = &quot;error.log&quot;
    infoLogFile  = &quot;info.log&quot;
)

func openLogFile(filename string) (*os.File, error) {
    return os.OpenFile(
        filename,
        os.O_CREATE|os.O_WRONLY|os.O_APPEND,
        0664,
    )
}

func main() {
    errorFile, err := openLogFile(errorLogFile)
    if err != nil {
        log.Fatalf(&quot;ERROR opening error log: %s: %v&quot;, errorLogFile, err)
    }
    defer errorFile.Close()

    infoFile, err := openLogFile(infoLogFile)
    if err != nil {
        log.Fatalf(&quot;ERRRO opening info log: %s: %v&quot;, infoLogFile, err)
    }
    defer infoFile.Close()

    eLog :=
        log.New(errorFile, &quot;ERROR: &quot;, log.Ldate|log.Ltime|log.Lshortfile)
    iLog :=
        log.New(infoFile, &quot;INFO: &quot;, log.Ldate|log.Ltime)

    eLog.Println(&quot;ERROR&quot;)
    iLog.Println(&quot;INFO&quot;)
}
</code></pre>
<h3 id="prettyprint-structs">PrettyPrint Structs</h3>
<pre><code class="language-go">func prettyPrintStruct(s interface{}) {
    result, _ := json.MarshalIndent(s, &quot;&quot;, &quot;\t&quot;)
    fmt.Print(string(result), &quot;\n&quot;)
}
</code></pre>
<hr />
<h2 id="flags">FLAGS</h2>
<h3 id="binarios-con-versiones">Binarios con versiones</h3>
<pre><code class="language-go">package main

import (
    &quot;flag&quot;
    &quot;fmt&quot;
    &quot;os&quot;
)

var version = &quot;0.0.0&quot;
var when = &quot;undefined&quot;

func main() {
    checkFlags()
    fmt.Println(&quot;Continue...&quot;)
}

func checkFlags() {
    versionFlag := flag.Bool(&quot;v&quot;, false, &quot;Show current version and exit&quot;)
    flag.Parse()
    switch {
    case *versionFlag:
        fmt.Printf(&quot;Version:\t: %s\n&quot;, version)
        fmt.Printf(&quot;Date   :\t: %s\n&quot;, when)
        os.Exit(0)
    }
}

/*
go build  -ldflags=&quot;
-X 'main.version=v0.2.0' 
-X 'main.when=$(date -u +%F_%T)'&quot;

go build  -ldflags=&quot;-X 'main.when=$(date -u +%F_%T)'&quot;

luego podemos hacer ./binary -v
*/
</code></pre>
<h3 id="args-flags-test">Args + Flags + test</h3>
<pre><code class="language-makefile">#go build -ldflags=&quot;-X 'main.when=$(date -u +%F_%T)'&quot;
DATE=$(shell date -u +%F_%T)
LDFLAGS=-ldflags &quot;-X main.when=$(DATE)&quot;

all: build

build:
    go build $(LDFLAGS) 

clean:
    rm binary
</code></pre>
<pre><code class="language-go">// main.go
var version = &quot;0.0.1&quot;
var when = &quot;&quot;

func main() {
    tasks := checkFlags()

    fmt.Println(&quot;USER =&gt; &quot;, getUserName())
    fmt.Println(&quot;TASKS=&quot;, tasks)
}

func checkFlags() []string {
    if len(os.Args) &gt; 1 &amp;&amp; os.Args[1] == &quot;-v&quot; {
        versionFlag := flag.Bool(&quot;v&quot;, false, &quot;Show Version&quot;)
        flag.Parse()
        if *versionFlag {
            fmt.Printf(&quot;Version -&gt;\t%s\n&quot;, version)
            fmt.Printf(&quot;Date    -&gt;\t%s\n&quot;, when)
            os.Exit(0)
        }
    }
    var result []string
    validFlags := []string{&quot;vnstat&quot;, &quot;www&quot;, &quot;cloud&quot;, &quot;mysql&quot;, &quot;rsync&quot;}

    for _, arg := range os.Args[1:] {
        if strings.HasPrefix(arg, &quot;-&quot;) {
            flag := strings.TrimPrefix(arg, &quot;-&quot;)
            for _, validFlag := range validFlags {
                if flag == validFlag {
                    if !includes(result, validFlag) {
                        result = append(result, validFlag)
                    }
                }
            }
        }
    }
    return result
}

func getUserName() string {
    currentUser, err := user.Current()
    if err != nil {
        fmt.Println(&quot;Error:&quot;, err)
        os.Exit(0)
    }
    return currentUser.Username
}

func includes(slice []string, element string) bool {
    for _, v := range slice {
        if v == element {
            return true
        }
    }
    return false
}

// main_test.go
func TestCheckFlags(t *testing.T) {
    tests := []struct {
        name     string
        args     []string
        expected []string
    }{
        {&quot;Test vnstat flag&quot;, []string{&quot;cmd&quot;, &quot;-vnstat&quot;},
            []string{&quot;vnstat&quot;}},
        {&quot;Test www flag&quot;, []string{&quot;cmd&quot;, &quot;-www&quot;},
            []string{&quot;www&quot;}},
        {&quot;Test cloud flag&quot;, []string{&quot;cmd&quot;, &quot;-cloud&quot;},
            []string{&quot;cloud&quot;}},
        {&quot;Test mysql flag&quot;, []string{&quot;cmd&quot;, &quot;-mysql&quot;},
            []string{&quot;mysql&quot;}},
        {&quot;Test rsync flag&quot;, []string{&quot;cmd&quot;, &quot;-rsync&quot;},
            []string{&quot;rsync&quot;}},
        {&quot;Test vnstat and mysql flags&quot;,
          []string{&quot;cmd&quot;, &quot;-vnstat&quot;, &quot;-mysql&quot;},
            []string{&quot;vnstat&quot;, &quot;mysql&quot;}},
        {&quot;Test no flags&quot;, []string{&quot;cmd&quot;}, []string{}},
        {&quot;Test repeated flags&quot;, []string{&quot;cmd&quot;, &quot;-www&quot;, &quot;-www&quot;},
            []string{&quot;www&quot;}},
        {&quot;Test unknown flag&quot;, []string{&quot;cmd&quot;, &quot;-unknown&quot;},
            []string{}},
        {&quot;Test multiple unknown flags&quot;, 
        []string{&quot;cmd&quot;, &quot;-unknown&quot;, &quot;-anotherunknown&quot;}, 
        []string{}},
        {&quot;Test multiple unknown and known flags&quot;,
          []string{&quot;cmd&quot;, &quot;-www&quot;, &quot;-unknown&quot;, &quot;-rsync&quot;, &quot;-anotherunk&quot;},
            []string{&quot;www&quot;, &quot;rsync&quot;}},
    }

    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            os.Args = tt.args
            flag.CommandLine = flag.NewFlagSet(os.Args[0], flag.ExitOnError)
            result := checkFlags()
            if len(result) != len(tt.expected) {
                t.Errorf(&quot;expected length %d, got %d&quot;,
                 len(tt.expected), len(result))
            }
            for i, v := range tt.expected {
                if result[i] != v {
                    t.Errorf(&quot;expected %s at index %d, got %s&quot;, 
                    v, i, result[i])
                }
            }
        })
    }
}


</code></pre>
<hr />
<h2 id="organizacion-de-codigo">ORGANIZACION DE CODIGO</h2>
<h3 id="compartir-structs-entre-paquetes">Compartir structs entre paquetes</h3>
<pre><code class="language-go">// main.go
package main

import (
    s &quot;pruebas/secondarypkg&quot;
    &quot;time&quot;
)

func main() {
    p := &amp;s.Placeholder{
        Name: &quot;FooBar&quot;,
        Date: time.Now().String(),
    }
    s.Foo(p)
}

// secondarypkg/otro.go
package secondarypkg

import &quot;fmt&quot;

type Placeholder struct {
    Name string
    Date string
}

func Foo(p *Placeholder) {
    fmt.Println(p.Date, p.Name)
}
</code></pre>
<pre><code class="language-go">// main.go
package main

import (
    s &quot;pruebas/paquete&quot;
    &quot;time&quot;
)
func main() {
    p := s.NewPlaceHolder(&quot;FooBar&quot;, time.Now().String())
    p.Foo()
}

// secondarypkg/otro.go
package secondarypkg

import &quot;fmt&quot;

type Placeholder struct {
    Name string
    Date string
}

func (p *Placeholder) Foo() {
    fmt.Println(p.Date, p.Name)
}

func NewPlaceHolder(name string, date string) *Placeholder {
    return &amp;Placeholder{
        Name: name,
        Date: date,
    }
}
</code></pre>
<p>Lo mismo usando interfaces</p>
<pre><code class="language-go">// main.go
package main

import (
    s &quot;pruebas/paquete&quot;
    &quot;time&quot;
)

func main() {
    p := s.NewPlaceHolder(&quot;FooBar&quot;, time.Now().String())
    p.Foo()
}

// secondarypkg/otro.go
package secondarypkg

import &quot;fmt&quot;

type PlaceHolder interface {
    Foo()
}

type placeholder struct {
    Name string
    Date string
}

func (p *placeholder) Foo() {
    fmt.Println(p.Date, p.Name)
}

func NewPlaceHolder(name string, date string) PlaceHolder {
    return &amp;placeholder{
        Name: name,
        Date: date,
    }
}
</code></pre>
<hr />
          
          
        </div>
      </div>
    </div>
    <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
      <div class="sphinxsidebarwrapper">
        <!--
  <p class="logo">
    <a href="..">
      <img class="logo" src="../_img/chuletas128.png" title="Chuletas">
    </a>
  </p>
  



        
        <h2>Navigation</h2>


<ul>
  
      
        <li>
          <a href="">Menu</a>
        </li>
      
    
      
        <li>
          <a href="html/">HTML</a>
        </li>
      
    
      
        <li>
          <a href="css/">CSS</a>
        </li>
      
    
      
        <li>
          <a href="frontend/">Front End</a>
        </li>
      
    
      
        <li>
          <a href="javascript/">Javascript</a>
        </li>
      
    
      
        <li>
          <a href="javascript-apis/">Javascript APIs</a>
        </li>
      
    
      
        <li>
          <a href="javascript-para-web/">Javascript para web</a>
        </li>
      
    
      
        <li>
          <a href="javascript-snippets/">Javascript snippets</a>
        </li>
      
    
      
        <li>
          <a href="reactjs/">Reactjs</a>
        </li>
      
    
      
        <li>
          <a href="nodejs/">Nodejs</a>
        </li>
      
    
      
        <li>
          <a href="expressjs/">Expressjs</a>
        </li>
      
    
      
        <li>
          <a href="nodejs-snippets/">Nodejs snippets</a>
        </li>
      
    
      
        <li>
          <a href="nodejs-bases-de-datos/">Nodejs Bases de Datos</a>
        </li>
      
    
      
        <li>
          <a href="golang/">Golang</a>
        </li>
      
    
      
        <li>
          <a href="golang-para-web/">Golang para web</a>
        </li>
      
    
      
        <li>
          <a href="golang-snippets/">Golang snippets</a>
        </li>
      
    
      
        <li>
          <a href="golang-bases-de-datos/">Golang Bases de Datos</a>
        </li>
      
    
      
        <li>
          <a href="debian/">Debian</a>
        </li>
      
    
      
        <li>
          <a href="varios/">Varios</a>
        </li>
      
    
  </ul>
        



<h3>Contenidos</h3>

<nav>
  

<ul>
  
  <li><a href="#sendreceive-data">SEND/RECEIVE DATA</a></li>
  <ul>
  
  <li><a href="#sendresponse">SendResponse</a></li>
  <ul>
  
</ul>
  
  <li><a href="#fetch-get">Fetch GET</a></li>
  <ul>
  
</ul>
  
  <li><a href="#dogetconcurrentrequest">DoGetConcurrentRequest</a></li>
  <ul>
  
</ul>
  
  <li><a href="#fetchpost">fetchPOST</a></li>
  <ul>
  
</ul>
  
  <li><a href="#fetchpost-with-params">fetchPOST with params</a></li>
  <ul>
  
</ul>
  
  <li><a href="#getinterfacestypes">GetInterfacesTypes</a></li>
  <ul>
  
</ul>
  
  <li><a href="#isjson">IsJSON</a></li>
  <ul>
  
</ul>
  
  <li><a href="#ispointer">IsPointer</a></li>
  <ul>
  
</ul>
  
</ul>
  
  <li><a href="#files">FILES</a></li>
  <ul>
  
  <li><a href="#readfile">ReadFile</a></li>
  <ul>
  
</ul>
  
  <li><a href="#writefile">WriteFile</a></li>
  <ul>
  
</ul>
  
  <li><a href="#loadjson-from-file">LoadJSON from File</a></li>
  <ul>
  
</ul>
  
  <li><a href="#writejsontofile">WriteJSONtoFile</a></li>
  <ul>
  
</ul>
  
  <li><a href="#downloadfile">DownloadFile</a></li>
  <ul>
  
</ul>
  
  <li><a href="#sendfilefromservertoclient">SendFileFromServerToClient</a></li>
  <ul>
  
</ul>
  
  <li><a href="#parsecsvfile">ParseCSVFile</a></li>
  <ul>
  
</ul>
  
</ul>
  
  <li><a href="#http-server">HTTP SERVER</a></li>
  <ul>
  
  <li><a href="#wrapper">Wrapper</a></li>
  <ul>
  
</ul>
  
  <li><a href="#handle-handlefunc">Handle + HandleFunc</a></li>
  <ul>
  
</ul>
  
  <li><a href="#handler">Handler</a></li>
  <ul>
  
</ul>
  
  <li><a href="#ejemplo-completo">Ejemplo Completo</a></li>
  <ul>
  
</ul>
  
</ul>
  
  <li><a href="#network">NETWORK</a></li>
  <ul>
  
  <li><a href="#getip">GetIP</a></li>
  <ul>
  
</ul>
  
  <li><a href="#getrequestorigin">GetRequestOrigin</a></li>
  <ul>
  
</ul>
  
  <li><a href="#isvalidurl">IsValidURL</a></li>
  <ul>
  
</ul>
  
  <li><a href="#existsurl">ExistsURL</a></li>
  <ul>
  
</ul>
  
  <li><a href="#getlanguage">GetLanguage</a></li>
  <ul>
  
</ul>
  
  <li><a href="#removeprotocolfromurl">RemoveProtocolFromURL</a></li>
  <ul>
  
</ul>
  
  <li><a href="#removeprotocolandwwwfromurl">RemoveProtocolAndWWWFromURL</a></li>
  <ul>
  
</ul>
  
  <li><a href="#nginx-return-444">Nginx return 444</a></li>
  <ul>
  
</ul>
  
  <li><a href="#slow-response">Slow Response</a></li>
  <ul>
  
</ul>
  
</ul>
  
  <li><a href="#numbers">NUMBERS</a></li>
  <ul>
  
  <li><a href="#getrandomint">GetRandomInt</a></li>
  <ul>
  
</ul>
  
  <li><a href="#roundfloat64">RoundFloat64</a></li>
  <ul>
  
</ul>
  
  <li><a href="#roundfloat32">RoundFloat32</a></li>
  <ul>
  
</ul>
  
  <li><a href="#reversesliceint">ReverseSliceInt</a></li>
  <ul>
  
</ul>
  
  <li><a href="#transposematrixint">TransposeMatrixInt</a></li>
  <ul>
  
</ul>
  
  <li><a href="#slicecontainsint">SliceContainsInt</a></li>
  <ul>
  
</ul>
  
</ul>
  
  <li><a href="#strings">STRINGS</a></li>
  <ul>
  
  <li><a href="#removeallwhitespaces">RemoveAllWhitespaces</a></li>
  <ul>
  
</ul>
  
  <li><a href="#replaceallwhitespacesbychar">ReplaceAllWhitespacesByChar</a></li>
  <ul>
  
</ul>
  
  <li><a href="#reverseslicestring">ReverseSliceString</a></li>
  <ul>
  
</ul>
  
  <li><a href="#transposematrixstring">TransposeMatrixString</a></li>
  <ul>
  
</ul>
  
  <li><a href="#slicecontainsstring">SliceContainsString</a></li>
  <ul>
  
</ul>
  
</ul>
  
  <li><a href="#os">OS</a></li>
  <ul>
  
  <li><a href="#execcommand">execCommand</a></li>
  <ul>
  
</ul>
  
</ul>
  
  <li><a href="#time">TIME</a></li>
  <ul>
  
  <li><a href="#parsestringtotime">ParseStringToTime</a></li>
  <ul>
  
</ul>
  
  <li><a href="#onceadaytask">OnceADayTask</a></li>
  <ul>
  
</ul>
  
  <li><a href="#setinterval">SetInterval</a></li>
  <ul>
  
</ul>
  
</ul>
  
  <li><a href="#logs">LOGS</a></li>
  <ul>
  
  <li><a href="#custom-logs">Custom Logs</a></li>
  <ul>
  
</ul>
  
  <li><a href="#prettyprint-structs">PrettyPrint Structs</a></li>
  <ul>
  
</ul>
  
</ul>
  
  <li><a href="#flags">FLAGS</a></li>
  <ul>
  
  <li><a href="#binarios-con-versiones">Binarios con versiones</a></li>
  <ul>
  
</ul>
  
  <li><a href="#args-flags-test">Args + Flags + test</a></li>
  <ul>
  
</ul>
  
</ul>
  
  <li><a href="#organizacion-de-codigo">ORGANIZACION DE CODIGO</a></li>
  <ul>
  
  <li><a href="#compartir-structs-entre-paquetes">Compartir structs entre paquetes</a></li>
  <ul>
  
</ul>
  
</ul>
  
</ul>


  
</nav>
        
        <div id="searchbox" style="display: none;" role="search">
  <h3>Quick search</h3>
  <form class="search" action="../search.html" method="get">
    <input name="q" type="text">
    <input value="Go" type="submit">
  </form>
  <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
  </p>
</div>
<script type="text/javascript">
  document.getElementById("searchbox").style.display = "block";
</script>
        -->

        

        
        
  <p class="logo">
    <a href="..">
      <img class="logo" src="../_img/chuletas128.png" title="Chuletas">
    </a>
  </p>
  



        
        <div class="menuNav">

  
  <ul>
    
    
    <li>
      <a href="../">Menu</a>
    </li>
    
    
    
    <li>
      <a href="../html/">HTML</a>
    </li>
    
    
    
    <li>
      <a href="../css/">CSS</a>
    </li>
    
    
    
    <li>
      <a href="../frontend/">Front End</a>
    </li>
    
    
    
    <li>
      <a href="../javascript/">Javascript</a>
    </li>
    
    
    
    <li>
      <a href="../javascript-apis/">Javascript APIs</a>
    </li>
    
    
    
    <li>
      <a href="../javascript-para-web/">Javascript para web</a>
    </li>
    
    
    
    <li>
      <a href="../javascript-snippets/">Javascript snippets</a>
    </li>
    
    
    
    <li>
      <a href="../reactjs/">Reactjs</a>
    </li>
    
    
    
    <li>
      <a href="../nodejs/">Nodejs</a>
    </li>
    
    
    
    <li>
      <a href="../expressjs/">Expressjs</a>
    </li>
    
    
    
    <li>
      <a href="../nodejs-snippets/">Nodejs snippets</a>
    </li>
    
    
    
    <li>
      <a href="../nodejs-bases-de-datos/">Nodejs Bases de Datos</a>
    </li>
    
    
    
    <li>
      <a href="../golang/">Golang</a>
    </li>
    
    
    
    <li>
      <a href="../golang-para-web/">Golang para web</a>
    </li>
    
    
    
    <li>
      <a href="../golang-snippets/">Golang snippets</a>
    </li>
    
    
    
    <li>
      <a href="../golang-bases-de-datos/">Golang Bases de Datos</a>
    </li>
    
    
    
    <li>
      <a href="../debian/">Debian</a>
    </li>
    
    
    
    <li>
      <a href="../varios/">Varios</a>
    </li>
    
    
  </ul>
</div>
        
        



<h3>Contenidos</h3>

<nav>
  

<ul>
  
  <li><a href="#sendreceive-data">SEND/RECEIVE DATA</a></li>
  <ul>
  
  <li><a href="#sendresponse">SendResponse</a></li>
  <ul>
  
</ul>
  
  <li><a href="#fetch-get">Fetch GET</a></li>
  <ul>
  
</ul>
  
  <li><a href="#dogetconcurrentrequest">DoGetConcurrentRequest</a></li>
  <ul>
  
</ul>
  
  <li><a href="#fetchpost">fetchPOST</a></li>
  <ul>
  
</ul>
  
  <li><a href="#fetchpost-with-params">fetchPOST with params</a></li>
  <ul>
  
</ul>
  
  <li><a href="#getinterfacestypes">GetInterfacesTypes</a></li>
  <ul>
  
</ul>
  
  <li><a href="#isjson">IsJSON</a></li>
  <ul>
  
</ul>
  
  <li><a href="#ispointer">IsPointer</a></li>
  <ul>
  
</ul>
  
</ul>
  
  <li><a href="#files">FILES</a></li>
  <ul>
  
  <li><a href="#readfile">ReadFile</a></li>
  <ul>
  
</ul>
  
  <li><a href="#writefile">WriteFile</a></li>
  <ul>
  
</ul>
  
  <li><a href="#loadjson-from-file">LoadJSON from File</a></li>
  <ul>
  
</ul>
  
  <li><a href="#writejsontofile">WriteJSONtoFile</a></li>
  <ul>
  
</ul>
  
  <li><a href="#downloadfile">DownloadFile</a></li>
  <ul>
  
</ul>
  
  <li><a href="#sendfilefromservertoclient">SendFileFromServerToClient</a></li>
  <ul>
  
</ul>
  
  <li><a href="#parsecsvfile">ParseCSVFile</a></li>
  <ul>
  
</ul>
  
</ul>
  
  <li><a href="#http-server">HTTP SERVER</a></li>
  <ul>
  
  <li><a href="#wrapper">Wrapper</a></li>
  <ul>
  
</ul>
  
  <li><a href="#handle-handlefunc">Handle + HandleFunc</a></li>
  <ul>
  
</ul>
  
  <li><a href="#handler">Handler</a></li>
  <ul>
  
</ul>
  
  <li><a href="#ejemplo-completo">Ejemplo Completo</a></li>
  <ul>
  
</ul>
  
</ul>
  
  <li><a href="#network">NETWORK</a></li>
  <ul>
  
  <li><a href="#getip">GetIP</a></li>
  <ul>
  
</ul>
  
  <li><a href="#getrequestorigin">GetRequestOrigin</a></li>
  <ul>
  
</ul>
  
  <li><a href="#isvalidurl">IsValidURL</a></li>
  <ul>
  
</ul>
  
  <li><a href="#existsurl">ExistsURL</a></li>
  <ul>
  
</ul>
  
  <li><a href="#getlanguage">GetLanguage</a></li>
  <ul>
  
</ul>
  
  <li><a href="#removeprotocolfromurl">RemoveProtocolFromURL</a></li>
  <ul>
  
</ul>
  
  <li><a href="#removeprotocolandwwwfromurl">RemoveProtocolAndWWWFromURL</a></li>
  <ul>
  
</ul>
  
  <li><a href="#nginx-return-444">Nginx return 444</a></li>
  <ul>
  
</ul>
  
  <li><a href="#slow-response">Slow Response</a></li>
  <ul>
  
</ul>
  
</ul>
  
  <li><a href="#numbers">NUMBERS</a></li>
  <ul>
  
  <li><a href="#getrandomint">GetRandomInt</a></li>
  <ul>
  
</ul>
  
  <li><a href="#roundfloat64">RoundFloat64</a></li>
  <ul>
  
</ul>
  
  <li><a href="#roundfloat32">RoundFloat32</a></li>
  <ul>
  
</ul>
  
  <li><a href="#reversesliceint">ReverseSliceInt</a></li>
  <ul>
  
</ul>
  
  <li><a href="#transposematrixint">TransposeMatrixInt</a></li>
  <ul>
  
</ul>
  
  <li><a href="#slicecontainsint">SliceContainsInt</a></li>
  <ul>
  
</ul>
  
</ul>
  
  <li><a href="#strings">STRINGS</a></li>
  <ul>
  
  <li><a href="#removeallwhitespaces">RemoveAllWhitespaces</a></li>
  <ul>
  
</ul>
  
  <li><a href="#replaceallwhitespacesbychar">ReplaceAllWhitespacesByChar</a></li>
  <ul>
  
</ul>
  
  <li><a href="#reverseslicestring">ReverseSliceString</a></li>
  <ul>
  
</ul>
  
  <li><a href="#transposematrixstring">TransposeMatrixString</a></li>
  <ul>
  
</ul>
  
  <li><a href="#slicecontainsstring">SliceContainsString</a></li>
  <ul>
  
</ul>
  
</ul>
  
  <li><a href="#os">OS</a></li>
  <ul>
  
  <li><a href="#execcommand">execCommand</a></li>
  <ul>
  
</ul>
  
</ul>
  
  <li><a href="#time">TIME</a></li>
  <ul>
  
  <li><a href="#parsestringtotime">ParseStringToTime</a></li>
  <ul>
  
</ul>
  
  <li><a href="#onceadaytask">OnceADayTask</a></li>
  <ul>
  
</ul>
  
  <li><a href="#setinterval">SetInterval</a></li>
  <ul>
  
</ul>
  
</ul>
  
  <li><a href="#logs">LOGS</a></li>
  <ul>
  
  <li><a href="#custom-logs">Custom Logs</a></li>
  <ul>
  
</ul>
  
  <li><a href="#prettyprint-structs">PrettyPrint Structs</a></li>
  <ul>
  
</ul>
  
</ul>
  
  <li><a href="#flags">FLAGS</a></li>
  <ul>
  
  <li><a href="#binarios-con-versiones">Binarios con versiones</a></li>
  <ul>
  
</ul>
  
  <li><a href="#args-flags-test">Args + Flags + test</a></li>
  <ul>
  
</ul>
  
</ul>
  
  <li><a href="#organizacion-de-codigo">ORGANIZACION DE CODIGO</a></li>
  <ul>
  
  <li><a href="#compartir-structs-entre-paquetes">Compartir structs entre paquetes</a></li>
  <ul>
  
</ul>
  
</ul>
  
</ul>


  
</nav>
        

        

      </div>
    </div>
    <div class="clearer"></div>
  </div>

  
  <div class="footer">
    
    
    
    Powered by <a href="http://www.mkdocs.org">mkdocs 1.4.2</a>
    &amp; <a href="https://github.com/iamale/mkdocs-alabaster">mkdocs-alabaster</a>
    
  </div>
  

  <!--
  MkDocs version      : 1.4.2
  Docs Build Date UTC : 2025-02-18 16:42:07.611478+00:00
  -->
</body>

</html>